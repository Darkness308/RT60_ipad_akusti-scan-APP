name: AI Autofix Agent

on:
  repository_dispatch:
    types: [ci-failure-autofix]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to fix'
        required: true
        default: 'main'
      error_type:
        description: 'Type of error to fix'
        required: true
        type: choice
        options:
          - auto
          - import-error
          - pdf-test-failure
          - type-error
          - lint-error
          - dependency-error
          - build-error

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  MAX_FIX_ATTEMPTS: 5

jobs:
  autofix:
    runs-on: macos-15
    timeout-minutes: 30

    outputs:
      fix_applied: ${{ steps.apply_fixes.outputs.fix_applied }}
      error_type: ${{ steps.analyze.outputs.error_type }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.client_payload.branch || github.event.inputs.branch || 'main' }}
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.1'

    - name: Install Tools
      run: |
        brew install swiftlint swiftformat || true

    - name: Download and analyze error logs
      id: analyze
      run: |
        echo "üîç Analyzing CI failure..."

        # Get error information from dispatch payload
        ERROR_SUMMARY="${{ github.event.client_payload.error_summary || 'No error summary' }}"
        FAILED_STEP="${{ github.event.client_payload.failed_step || 'unknown' }}"
        WORKFLOW_RUN_ID="${{ github.event.client_payload.workflow_run_id || '0' }}"
        ATTEMPT="${{ github.event.client_payload.attempt || '1' }}"
        INPUT_ERROR_TYPE="${{ github.event.inputs.error_type || 'auto' }}"

        echo "Error Summary: $ERROR_SUMMARY"
        echo "Failed Step: $FAILED_STEP"
        echo "Attempt: $ATTEMPT of $MAX_FIX_ATTEMPTS"

        # Save error info to file for analysis
        echo "$ERROR_SUMMARY" > /tmp/ci_error.log
        echo "Failed step: $FAILED_STEP" >> /tmp/ci_error.log

        # Detect error type if auto
        if [ "$INPUT_ERROR_TYPE" = "auto" ]; then
          # Pattern matching for error types
          if echo "$ERROR_SUMMARY" | grep -qiE "import (iPadScannerApp|OldModule)"; then
            ERROR_TYPE="import-error"
          elif echo "$ERROR_SUMMARY" | grep -qiE "PDFRobustness|ReportContract|PDF.*missing"; then
            ERROR_TYPE="pdf-test-failure"
          elif echo "$ERROR_SUMMARY" | grep -qiE "cannot find type|undeclared type"; then
            ERROR_TYPE="type-error"
          elif echo "$ERROR_SUMMARY" | grep -qiE "SwiftLint|swiftformat|formatting"; then
            ERROR_TYPE="lint-error"
          elif echo "$ERROR_SUMMARY" | grep -qiE "package.*resolution|dependency"; then
            ERROR_TYPE="dependency-error"
          elif echo "$ERROR_SUMMARY" | grep -qiE "build.*failed|compile.*error"; then
            ERROR_TYPE="build-error"
          else
            ERROR_TYPE="unknown"
          fi
        else
          ERROR_TYPE="$INPUT_ERROR_TYPE"
        fi

        echo "Detected error type: $ERROR_TYPE"

        echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
        echo "attempt=$ATTEMPT" >> $GITHUB_OUTPUT
        echo "workflow_run_id=$WORKFLOW_RUN_ID" >> $GITHUB_OUTPUT

    - name: Run diagnostic build
      id: diagnostics
      continue-on-error: true
      run: |
        echo "üî¨ Running diagnostic build to capture errors..."

        # Build AcoustiScanConsolidated and capture errors
        cd AcoustiScanConsolidated
        swift build 2>&1 | tee /tmp/build_acoustiscan.log
        BUILD_RESULT=${PIPESTATUS[0]}
        cd ..

        # Build Export module
        cd Modules/Export
        swift build 2>&1 | tee /tmp/build_export.log
        EXPORT_BUILD_RESULT=${PIPESTATUS[0]}

        # Run tests to capture test failures
        swift test 2>&1 | tee /tmp/test_export.log || true
        cd ../..

        # Combine all error logs
        cat /tmp/build_acoustiscan.log >> /tmp/ci_error.log
        cat /tmp/build_export.log >> /tmp/ci_error.log
        cat /tmp/test_export.log >> /tmp/ci_error.log

        # Report status
        if [ $BUILD_RESULT -ne 0 ]; then
          echo "build_failed=true" >> $GITHUB_OUTPUT
        fi
        if [ $EXPORT_BUILD_RESULT -ne 0 ]; then
          echo "export_build_failed=true" >> $GITHUB_OUTPUT
        fi

    - name: Apply intelligent fixes
      id: apply_fixes
      run: |
        echo "üîß Applying intelligent fixes..."

        ERROR_TYPE="${{ steps.analyze.outputs.error_type }}"
        CHANGES_MADE=false

        # Make autofix engine executable
        chmod +x .github/scripts/autofix-engine.sh

        # Run the autofix engine
        .github/scripts/autofix-engine.sh /tmp/ci_error.log "$ERROR_TYPE" || true

        # ============================================================
        # SPECIFIC FIX STRATEGIES
        # ============================================================

        case "$ERROR_TYPE" in
          "import-error")
            echo "üì¶ Fixing import errors..."

            # Fix broken imports in test files
            find . -name "*.swift" -type f | while read file; do
              if grep -q "import iPadScannerApp" "$file" 2>/dev/null; then
                echo "  Fixing: $file"
                sed -i '' 's/import iPadScannerApp/import AcoustiScanConsolidated/g' "$file" 2>/dev/null || \
                sed -i 's/import iPadScannerApp/import AcoustiScanConsolidated/g' "$file"
                CHANGES_MADE=true
              fi
              if grep -q "@testable import iPadScannerApp" "$file" 2>/dev/null; then
                echo "  Fixing @testable: $file"
                sed -i '' 's/@testable import iPadScannerApp/@testable import AcoustiScanConsolidated/g' "$file" 2>/dev/null || \
                sed -i 's/@testable import iPadScannerApp/@testable import AcoustiScanConsolidated/g' "$file"
                CHANGES_MADE=true
              fi
            done

            # Fix class name references
            find . -name "*.swift" -type f | while read file; do
              if grep -q "RT60Calculation\." "$file" 2>/dev/null; then
                echo "  Fixing class name in: $file"
                sed -i '' 's/RT60Calculation\./RT60Calculator./g' "$file" 2>/dev/null || \
                sed -i 's/RT60Calculation\./RT60Calculator./g' "$file"
                CHANGES_MADE=true
              fi
            done
            ;;

          "pdf-test-failure")
            echo "üìÑ Analyzing PDF test failures..."

            # Check if required elements exist in renderers
            PDF_RENDERER="Modules/Export/Sources/ReportExport/PDFReportRenderer.swift"

            if [ -f "$PDF_RENDERER" ]; then
              # Verify core tokens section exists
              if ! grep -q "Core Tokens" "$PDF_RENDERER"; then
                echo "  ‚ö†Ô∏è Core Tokens section may need review"
              fi

              # Verify required frequencies
              if ! grep -q "125.*1000.*4000" "$PDF_RENDERER"; then
                echo "  ‚ö†Ô∏è Required frequencies may need review"
              fi

              # Verify DIN values
              for val in "0.6" "0.5" "0.48"; do
                if ! grep -q "$val" "$PDF_RENDERER"; then
                  echo "  ‚ö†Ô∏è DIN value $val may be missing"
                fi
              done
            fi
            ;;

          "lint-error")
            echo "üßπ Fixing lint errors..."

            # Run SwiftFormat
            swiftformat . --swiftversion 5.9 2>&1 || true
            CHANGES_MADE=true

            # Run SwiftLint autocorrect
            swiftlint --fix 2>&1 || true
            ;;

          "dependency-error")
            echo "üì¶ Fixing dependency errors..."

            # Clean and resolve for each package
            for dir in "AcoustiScanConsolidated" "Modules/Export"; do
              if [ -d "$dir" ]; then
                cd "$dir"
                rm -rf .build Package.resolved 2>/dev/null || true
                swift package clean 2>/dev/null || true
                swift package resolve 2>&1 || true
                cd - > /dev/null
              fi
            done
            CHANGES_MADE=true
            ;;

          "build-error"|"type-error")
            echo "üî® Attempting build error fixes..."

            # Clean all build artifacts
            find . -name ".build" -type d -exec rm -rf {} + 2>/dev/null || true
            find . -name "Package.resolved" -delete 2>/dev/null || true

            # Resolve packages fresh
            for dir in "AcoustiScanConsolidated" "Modules/Export"; do
              if [ -d "$dir" ]; then
                cd "$dir"
                swift package clean 2>/dev/null || true
                swift package resolve 2>&1 || true
                cd - > /dev/null
              fi
            done
            ;;

          *)
            echo "‚ùì Unknown error type - attempting general fixes..."

            # Run all formatters
            swiftformat . --swiftversion 5.9 2>&1 || true
            swiftlint --fix 2>&1 || true

            # Clean rebuild
            for dir in "AcoustiScanConsolidated" "Modules/Export"; do
              if [ -d "$dir" ]; then
                cd "$dir"
                swift package clean 2>/dev/null || true
                swift package resolve 2>&1 || true
                cd - > /dev/null
              fi
            done
            ;;
        esac

        # Check if any files were changed
        if git diff --quiet && git diff --staged --quiet; then
          echo "fix_applied=false" >> $GITHUB_OUTPUT
          echo "No changes detected"
        else
          echo "fix_applied=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Changes detected and ready to commit"
        fi

    - name: Verify fixes
      id: verify
      if: steps.apply_fixes.outputs.fix_applied == 'true'
      continue-on-error: true
      run: |
        echo "üîç Verifying fixes..."

        VERIFY_SUCCESS=true

        # Test AcoustiScanConsolidated build
        cd AcoustiScanConsolidated
        if swift build 2>&1; then
          echo "‚úÖ AcoustiScanConsolidated builds successfully"
        else
          echo "‚ùå AcoustiScanConsolidated still has build errors"
          VERIFY_SUCCESS=false
        fi
        cd ..

        # Test Export module build
        cd Modules/Export
        if swift build 2>&1; then
          echo "‚úÖ Export module builds successfully"
        else
          echo "‚ùå Export module still has build errors"
          VERIFY_SUCCESS=false
        fi
        cd ..

        if [ "$VERIFY_SUCCESS" = true ]; then
          echo "verify_success=true" >> $GITHUB_OUTPUT
        else
          echo "verify_success=false" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push fixes
      id: commit
      if: steps.apply_fixes.outputs.fix_applied == 'true'
      run: |
        echo "üìù Committing fixes..."

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Check for actual changes
        if git diff --quiet && git diff --staged --quiet; then
          echo "No changes to commit"
          echo "committed=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        git add -A

        ERROR_TYPE="${{ steps.analyze.outputs.error_type }}"
        ATTEMPT="${{ steps.analyze.outputs.attempt }}"
        VERIFY_STATUS="${{ steps.verify.outputs.verify_success }}"

        # Create detailed commit message
        COMMIT_MSG="fix(ci): auto-fix $ERROR_TYPE issues [attempt $ATTEMPT]

Automatic fixes applied by Self-Healing CI:
- Error type: $ERROR_TYPE
- Attempt: $ATTEMPT of $MAX_FIX_ATTEMPTS
- Verification: $VERIFY_STATUS

Changes made by autofix-agent workflow.
"

        git commit -m "$COMMIT_MSG" || {
          echo "Nothing to commit"
          echo "committed=false" >> $GITHUB_OUTPUT
          exit 0
        }

        # Push changes
        BRANCH="${{ github.event.client_payload.branch || github.event.inputs.branch || 'main' }}"
        git push origin HEAD:"$BRANCH" 2>&1 || {
          echo "Push failed, trying force-with-lease..."
          git push origin HEAD:"$BRANCH" --force-with-lease 2>&1 || {
            echo "Push failed completely"
            echo "committed=false" >> $GITHUB_OUTPUT
            exit 1
          }
        }

        echo "committed=true" >> $GITHUB_OUTPUT
        echo "‚úÖ Fixes committed and pushed"

    - name: Trigger CI re-run
      if: steps.commit.outputs.committed == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          console.log('üîÑ Triggering CI re-run after fixes...');

          // Wait for push to propagate
          await new Promise(resolve => setTimeout(resolve, 5000));

          const branch = '${{ github.event.client_payload.branch || github.event.inputs.branch || 'main' }}';

          try {
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-test.yml',
              ref: branch
            });
            console.log('‚úÖ Build workflow triggered on branch: ' + branch);
          } catch (error) {
            console.log('‚ö†Ô∏è Could not trigger workflow: ' + error.message);
          }

    - name: Update issue with results
      if: always()
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issueNumber = parseInt('${{ github.event.client_payload.issue_number }}') || 0;

          if (issueNumber === 0) {
            console.log('No issue number provided, skipping update');
            return;
          }

          const fixApplied = '${{ steps.apply_fixes.outputs.fix_applied }}' === 'true';
          const committed = '${{ steps.commit.outputs.committed }}' === 'true';
          const verifySuccess = '${{ steps.verify.outputs.verify_success }}' === 'true';
          const errorType = '${{ steps.analyze.outputs.error_type }}';
          const attempt = '${{ steps.analyze.outputs.attempt }}';

          let statusEmoji, statusText;

          if (committed && verifySuccess) {
            statusEmoji = '‚úÖ';
            statusText = 'Fixes applied and verified successfully';
          } else if (committed) {
            statusEmoji = 'üîß';
            statusText = 'Fixes applied, awaiting verification';
          } else if (fixApplied) {
            statusEmoji = '‚ö†Ô∏è';
            statusText = 'Changes detected but commit failed';
          } else {
            statusEmoji = '‚ùå';
            statusText = 'No automatic fixes could be applied';
          }

          const comment = `## ü§ñ Autofix Agent Report

          ${statusEmoji} **Status:** ${statusText}

          ### Analysis Details
          | Property | Value |
          |----------|-------|
          | Error Type | \`${errorType}\` |
          | Attempt | ${attempt}/${process.env.MAX_FIX_ATTEMPTS || 5} |
          | Fix Applied | ${fixApplied ? '‚úÖ Yes' : '‚ùå No'} |
          | Committed | ${committed ? '‚úÖ Yes' : '‚ùå No'} |
          | Verified | ${verifySuccess ? '‚úÖ Pass' : '‚è≥ Pending'} |

          ${committed ? 'üîÑ **Next:** CI workflow has been triggered. Monitoring for results...' : ''}
          ${!fixApplied ? '‚ö†Ô∏è **Note:** This error type may require manual intervention.' : ''}

          ---
          <sub>Generated by Self-Healing CI ‚Ä¢ Attempt ${attempt}</sub>`;

          try {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: comment
            });
            console.log('üìù Updated issue #' + issueNumber);
          } catch (error) {
            console.log('Failed to update issue: ' + error.message);
          }

    - name: Generate fix report artifact
      if: always()
      run: |
        mkdir -p artifacts

        echo "# Autofix Report" > artifacts/autofix-report.md
        echo "Generated: $(date)" >> artifacts/autofix-report.md
        echo "" >> artifacts/autofix-report.md
        echo "## Summary" >> artifacts/autofix-report.md
        echo "- Error Type: ${{ steps.analyze.outputs.error_type }}" >> artifacts/autofix-report.md
        echo "- Fix Applied: ${{ steps.apply_fixes.outputs.fix_applied }}" >> artifacts/autofix-report.md
        echo "- Committed: ${{ steps.commit.outputs.committed }}" >> artifacts/autofix-report.md
        echo "- Verified: ${{ steps.verify.outputs.verify_success }}" >> artifacts/autofix-report.md
        echo "" >> artifacts/autofix-report.md

        if [ -f /tmp/autofix.log ]; then
          echo "## Fix Log" >> artifacts/autofix-report.md
          cat /tmp/autofix.log >> artifacts/autofix-report.md
        fi

        if [ -f /tmp/ci_error.log ]; then
          echo "## Error Log (truncated)" >> artifacts/autofix-report.md
          head -100 /tmp/ci_error.log >> artifacts/autofix-report.md
        fi

    - name: Upload artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: autofix-report-${{ github.run_id }}
        path: artifacts/
        retention-days: 14
